### 反转

不需要递归，一次遍历即可。注意修改当前结点的指向前先要保存下一个结点，否则找不到下一个结点，循环不下去。

- 只有链表长度< 2，直接返回head
- 修改当前结点的指向前先要保存下一个结点
- 将head结点的next置为NULL
- 更新上一个结点位置，一共需要3个指针(上一结点、当前结点、和下一点结点)

问题的扩展是：

给定一个单链表的头节点 head，实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助）

如链表：10->2->3->5->1，K=2

以K为长度反转后：10->3->2->1->5

解决问题的思路是：

1. 首先还是将整个链表反转，1->5->3->2->10
2. 将反转的链表分成N/K+1段，即除末尾的一段，每段长度为K。{1->5, 3->2, 10}
3. 以段为单位再反向连接。10->3->2->1->5



### 删除倒数第K个结点

双指针，一个指针先走K步，这个指针到尾部时，另一个指针刚好指向倒数第K个结点



### 复制含两个指针的链表

一个指针指向下一个结点，一个指针指向任意结点，要是线性复杂度，并且只允许使用常数辅助空间。

把新创建的结点接在原结点的后面，然后就可以顺着原链表的连接关系构造出新链表的连接关系，太巧妙了。



### 两个链表公共部分的第一个结点

对齐两个链表，然后同时走。对齐链表有两种方法，一种是分别先走一遍链表，计算出两个链表的长度，然后长的链表先走多的那一部分路。第二种方法是，先把第二个链表接在第一个链表后面，把第一链表接在第二个链表末尾，这样重新构造了两个等长的链表，且两个链表末尾部分相同。



### 检测链表中的环

快慢指针



### 环的入口

快慢指针求环长，然后问题转成求两个链表的公共部分第一个结点

或者不用求环长，依然使用快慢指针，计算链表头距离重合位置长度，然后再用新的指针指向链表头，然后与环中慢指针同时走，也能同时走到环的入口，其实这也是两个链表的公共部分第一个结点的变形，但是老胡没看出来。