## 01背包问题

**问题描述：** 有 N 个物品和一个容量为 C 的背包， 放入第 i 个物品耗费的空间是wi，得到的价值是vi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义：

 `f[i][c]`表示 i 个物品恰好放入一个容量为 c 的背包可以获得的最大价值。注意这个状态定义不是问题的状态，是个一般性的状态表示，代入N、C才是问题的状态。小c可以是任意一个可能的容量。

状态转移：

物体从少到多、包容量从小到大转移状态。如何转移到一般性状态 `f[i][c]`。假设前一阶段的状态是最优状态（最优子结构），考虑第i个物品放还是不放，得到 `f[i][c]`。放的话，意味着前一个状态背包容量最大为c-wi，即状态为`f[i-1][c-wi]+v[i]`，这是一个子问题。不放，意味着放不下，否则定能使价值提高，状态为`f[i-1][c]`。

因此得到，

 `f[i][c] = max(f[i-1][c-wi]+v[i], f[i-1][c])`

假设前一阶段的状态是最优状态成立的条件是，可以得到类似上面的状态转移方程。

最后就是从已知的初始状态转移到问题状态。

 时间复杂度`O(C*N) `

参考：https://zhuanlan.zhihu.com/p/30959069

### 动态规划递归解法

```python
"""
w: 代表重量，weights
v: 代表价值，values
c: 代表容量，非体积的意思，capacity
"""
def _bag01(w, v, c, index):
    if index < 0 or c <= 0:
        return 0
    # 不放第index个物品
    res = _bag01(w, v, c, index-1)
    # 放第index个物品
	if w[index] < c:
        res = max(res, _bag01(w, v, c-w[index], index-1) + v[index])
    return res

def bag01(w, v, c):
    assert len(v) == len(w)
    return _bag01(w, v, c, len(v)-1)
```

### 动态规划循环写法

```python
def bag01(spaces, values, size):
    # 创建dp数组, 注意数组大小比spaces和values多1
    dp = [[0] * (size+1) for _ in range(len(spaces)+1)]
    # 状态转移
    for i in range(1, len(spaces)+1):
        for j in range(1, size+1):
            # 还可以放得下
            if spaces[i-1] <= j:
                # 这里dp的空间可以优化成1维的
            	dp[i][j] = max(dp[i-1][j], dp[i-1][j-spaces[i-1]] + values[i-1])
            else:
                dp[i][j] = dp[i-1][j]
    return dp[-1][-1]
```

举例：spaces=[0 , 1 , 3 , 2 , 6 , 2], values = [0 , 2 , 5 , 3 , 10 , 4], size=12

![img](assets/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/20170402135953834.jpg)

从表格中可以看出来：

1. 为什么需要从物体个数开始循环，因为不同的size对应的格子需要填满，在下一行可能需要使用到。
2. dp空间可以优化到1维，因为当前行的值只与上一行的值相关。当从左到右（从小到大）循环时，会覆盖掉上一行的值（j-spaces[i-1]在当前元素的左侧），内循环需要从右往左（从大到小）循环。
3. 如果问题是恰好装满背包，则除`dp[0][0]`其它位置(未定义转状态)元素需要初始化为-inf

## 完全背包

**问题描述**：有N种物品（每种物品无限件）和一个容量为V的背包。放入一个第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义：`f[i][v]`表示 i 种物品放入背包容量为v可以获得的最大价值。

状态转移：

考虑如何得到`f[i][v]`，即前一个阶段的状态考虑放第 i 种物品。放的话，假设第 i 种放 k 个，此时前一个阶段状态为 `f[i-1][v-k*Ci]`，不放的话相当于k=0，k的范围是[0, v/Ci]

因此得到，

`f[i][v] = max{ f[i-1][v-kCi] + kWi | 0 <= k <= v/Ci}`

 当k的取值为0,1时，这就是01背包的状态转移方程 

 时间复杂度`O(V*N*sum{V/Ci}) `



## 多重背包

问题描述：有N种物品（每种物品Mi件）和一个容量为V的背包。放入第i种物品耗费的空间是Ci，得到

的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义： `f[i][v]`表示 i 种物品放入一个容量为v的背包可以获得的最大价值。 

状态转移：

考虑如何得到`f[i][v]`，即前一个阶段的状态考虑放第 i 种物品。放的话，假设第 i 种放 k 个，此时前一个阶段状态为 `f[i-1][v-k*Ci]`，不放的话相当于k=0，k的范围是`[0, min(Mi, v/Ci)]`

因此得到，

` f[i][v] = max{ f[i-1][v - kCi] + kWi | 0 <= k <= min(Mi, v/Ci) } `

 时间复杂度`O(V*N*sum{min(Mi, V/Ci)}) `

