## 01背包问题

**问题描述：** 有 N 个物品和一个容量为 C 的背包， 放入第 i 个物品耗费的空间是wi，得到的价值是vi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义：

 `f[i][c]`表示 i 个物品恰好放入一个容量为 c 的背包可以获得的最大价值。注意这个状态定义不是问题的状态，是个一般性的状态表示，代入N、C才是问题的状态。小c可以是任意一个可能的容量。

状态转移：

物体从少到多、包容量从小到大转移状态。如何转移到一般性状态 `f[i][c]`。假设前一阶段的状态是最优状态（最优子结构），考虑第i个物品放还是不放，得到 `f[i][c]`。放的话，意味着前一个状态背包容量最大为c-wi，即状态为`f[i-1][c-wi]+v[i]`，这是一个子问题。不放，意味着放不下，否则定能使价值提高，状态为`f[i-1][c]`。

因此得到，

 `f[i][c] = max(f[i-1][c-wi]+v[i], f[i-1][c])`

假设前一阶段的状态是最优状态成立的条件是，可以得到类似上面的状态转移方程。

最后就是从已知的初始状态转移到问题状态。

 时间复杂度`O(C*N) `

参考：https://zhuanlan.zhihu.com/p/30959069

### 动态规划递归解法

```python
"""
w: 代表重量，weights
v: 代表价值，values
c: 代表容量，非体积的意思，capacity
"""
def _bag01(w, v, c, index):
    if index < 0 or c <= 0:
        return 0
    # 不放第index个物品
    res = _bag01(w, v, c, index-1)
    # 放第index个物品
	if w[index] < c:
        res = max(res, _bag01(w, v, c-w[index], index-1) + v[index])
    return res

def bag01(w, v, c):
    assert len(v) == len(w)
    return _bag01(w, v, c, len(v)-1)
```

### 动态规划循环写法

```python
def bag01(w, v, c):
    # 创建dp数组
    dp = [[0] * c for _ in range(len(v))]
    # 初始化dp[0][ci]: 容量为ci的背包放第0个物品的情况
    for ci in range(c):
        dp[0][ci] = w[0] if w[0] <= ci else 0
    # 状态转移
    for i in range(1, len(w)):
        for j in range(c):
            if w[i] < j:
            	dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
            else:
                dp[i][j] = dp[i-1][j]
    return dp[len(w)-1][c]
```



## 完全背包

**问题描述**：有N种物品（每种物品无限件）和一个容量为V的背包。放入一个第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义：`f[i][v]`表示 i 种物品放入背包容量为v可以获得的最大价值。

状态转移：

考虑如何得到`f[i][v]`，即前一个阶段的状态考虑放第 i 种物品。放的话，假设第 i 种放 k 个，此时前一个阶段状态为 `f[i-1][v-k*Ci]`，不放的话相当于k=0，k的范围是[0, v/Ci]

因此得到，

`f[i][v] = max{ f[i-1][v-kCi] + kWi | 0 <= k <= v/Ci}`

 当k的取值为0,1时，这就是01背包的状态转移方程 

 时间复杂度`O(V*N*sum{V/Ci}) `



## 多重背包

问题描述：有N种物品（每种物品Mi件）和一个容量为V的背包。放入第i种物品耗费的空间是Ci，得到

的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）

状态定义： `f[i][v]`表示 i 种物品放入一个容量为v的背包可以获得的最大价值。 

状态转移：

考虑如何得到`f[i][v]`，即前一个阶段的状态考虑放第 i 种物品。放的话，假设第 i 种放 k 个，此时前一个阶段状态为 `f[i-1][v-k*Ci]`，不放的话相当于k=0，k的范围是`[0, min(Mi, v/Ci)]`

因此得到，

` f[i][v] = max{ f[i-1][v - kCi] + kWi | 0 <= k <= min(Mi, v/Ci) } `

 时间复杂度`O(V*N*sum{min(Mi, V/Ci)}) `

