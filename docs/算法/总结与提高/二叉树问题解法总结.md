### 前言

二叉树相关的问题在面试中出现的频率非常之高，有必要归纳问题的相似性以及特异性。

二叉树的遍历是解决所有与二叉树相关问题的基础。递归是思考解决二叉树问题的一种方法，大部分二叉树问题均可以使用递归来解决。



### 三种标准遍历

前序、中序、后序；递归、非递归

其中后序非递归遍历最难，需要标记访问过的右子结点



### 层次打印

先保存的先打印，所以是使用队列结构



### 之字形打印

奇数行：从左向右打印，先保存左子结点再保存右子结点；下层遍历时，本层先保存的后打印

偶数行：从右向左打印，先保存右子结点在保存左子结点；下层遍历时，本层先保存的后打印

因此需要使用两个栈结构，分别以不同的左右结点顺序保存。



### 二叉树给定结点的下一个结点

前序、中序、后序访问方式的下一个结点各不同，主要是熟悉每种访问方式的特点。解决关键是分类讨论，不要漏掉情况。假如当前结点为给定结点，

中序：如果当前结点右子树不为空，则下一结点为右子树的最左子结点；如果当前结点无右子树，并且是父结点的左子结点，则下一结点为其父结点；如果当前结点无右子结点并且不是父结点的右子结点，则一直向上查找，直到找到某一结点为其父结点的左子结点，此父结点即为下一结点。也可以不用这么麻烦，使用一个变量记录是否已访问到目标结点，然后在继续访问中查询当前状态，如果已访问到目标结点，并且当前结点不为NULL，则保存此结点，退出访问。



### 二叉树镜像/相同

判断一颗二叉树是否是对称的，或者判断两颗二叉树是否互问镜像，或者判断两颗二叉树是否相同，这些问题的解法都是类似的，即用两个指针同步访问，每一步值都相同或都为NULL，直到访问结束，则输出true，否则输出Flase。只不过，对于镜像问题，左右子结点的访问顺序需要交换。



### 序列化或反序列化二叉树

序列化二叉树即按某种顺序将二叉树保存到磁盘中，反序列化则是从磁盘中读出数组按某种顺序构建二叉树到内存。这也是考察二叉树的三种遍历方式，此外还需注意所用语言的流处理操作，从流中读入数据和输出数据到流，C++使用istream和ostream类以及>>和<<操作符。Python使用open函数返回的对象的readline和write函数。



### 二叉树的深度、直径

递归解法很简答，每次求左子树的深度和右子树的深度，返回的当前子树深度为 `max(depth(p->left), depth(p->right)) + 1`，两行代码：

```cpp
int depth(TreeNode* root) {
    if (root == NULL) return 0;
    return max(depth(root->left), depth(root->right)) + 1;
}
```

所谓树的直径指树中相距最远的两个结点之间的距离，是以树的深度为基础。只要把深度计算和直径计算融合在一起即可，时间复杂度为O(n)。当前子树的直径为`左子树的深度+右子树的深度`，注意一定是从叶子结点向根结点统计，否则结论不成立。



### 重建二叉树

二叉树重建问题是给定两种不同遍历方式得到的序列，由此反推二叉树的结构。

依然是二分法(这里所述的二分法，不是指只需要解决问题的一半，而是指一个问题可以被分为两个独立的子问题)，由一个序列元素想办法找到另一个序列的中间结点元素，然后将序列分成左子树和右子树，递归地解决。



### 二叉树中和为某一值的路径

路径指从根结点到叶子结点所经过的结点构成的一条路径，解决问题的关键：

- 必须使用前序遍历，从根结点开始
- 一边遍历一边保存结点，回溯时删除结点；使用递归则无需保存结点，只需保存结点和
- 不断更新保存的结点和
- 在叶子结点做判断，如果符合条件，则打印路径，打印路径要从根结点开始打印，因此不要使用栈保存结点，可以使用vector，添加和删除结点分别使用push_back和pop_back

如果此题扩展成路径可为任意两个可达的结点之间构成一条路径，则每个结点都需要做多次判断，时间复杂度为O(n^2)



### 二叉树中两个结点的最低公共祖先（LCA问题）

如果是一颗二叉搜索树，则只需要在回溯时判断两个结点是否分别在当前结点的左子树和右子树中，此时解决问题的复杂度为O(n)。

如果是一颗普通的树且没有子结点指向父结点的连接，则分别使用前序遍历，搜索这两个结点，然后将跟结点到目标结点的路径抽出，形成两个链表（如果可以修改原树，则可以将原树的另一个分支置NULL，而不用创建链表），然后问题转为求两个链表的第一个公共结点。时间复杂度为O(n)，空间复杂度为O(n)。

如果这是一颗有子结点指向父结点的连接的树，则只需要在原位置反向查找，时间复杂度为O(n)，常数空间复杂度。

如果这是一颗普通的树，可能是四叉树、五叉树等，则仅是查找方法与二叉树略有不同，其余转换均相同。



### 二叉搜索树查找

二分法



### 二叉搜索树删除/插入结点

代码稍长，肯定无法记住。解决问题的关键是思考问题的方法，如果每次都使用正确的思考方式，那么总能很快解决问题。先考虑删除结点，插入结点与删除结点类似。

删除一颗树中某一结点，情况不外乎以下几种：

1. 如果存在父结点，打断与父结点的连接。很多人觉得这种情况需要使用额外的变量记录父结点，因为一般的二叉树是单向访问，一旦访问到子结点将无法在子结点的层次获取到父结点。其实我们可以将打断与重新连接放在一起思考，这是就可以将打断子结点与父结点的连接任务交给父结点，使用递归就是返回当前层次的根结点，在上一低递归层次重新连接。所以这个操作解决了断1个连接和重连1个连接。
2. 打断当前结点与其左右子树的连接。当然如果当前结点没有子树，就不用断了，直接删除就好。此种情况需要断2个连接，重连2个连接。
3. 为保持有序性，必然要重新选择一个结点填补此位置，合适的结点是左子树的最大结点或右子树的最小结点。选定一个，断掉选中结点与其父结点的连接、选中结点与其左或右子结点的连接。重新安排选中结点的父结点和左或右子结点的连接。此种情况需要断2个连接，重连1个连接。

最多一共需要断5个连接，重新连4个连接，如果每个连接都考虑到了，这道题一定可以解出来，只是时间问题。

插入结点比删除结点简单，分析方法是一样的。



### 判断序列是否是某二叉搜索树的后序遍历结果

二分法。关键在于找到中间结点，然后把序列分成两半，一半是左子树(连续的小于中间结点的元素)，一半是右子树(连续的大于中间结点的元素)。显然序列的最后一个元素是整颗的根结点。如果中间结点无法将序列分成两个子树，则输出flase