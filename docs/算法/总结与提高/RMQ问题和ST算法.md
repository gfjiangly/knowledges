## RMQ问题(Range Minimum/Maximum Query)

对于长度为n的数组A，回答若干询问`RMQ(A, i, j), 0<=i<=j<=n-1)`，返回数组A中下标在`[i, j]`范围内的最小（大）值。

也就是说，RMQ问题是指求区间最值的问题。最简单的方法，就是遍历数组直接搜索，但是这种方式时间复杂度是O(n)。对于数组长度较大，性能要求高的场景不适用。


## ST(Sparse Table)算法

ST（Sparse Table）算法是一个非常有名的在线处理RMQ问题的算法，它可以在O(nlogn)时间内进行预处理，然后在O(1)时间内回答每个查询。其实就是动态规划的解法，适合在线计算，因为以前所有的计算结果都是当前计算的基础，没有太多多余的计算，代价是稀疏表占用了较多内存。

### 预处理，建立稀疏表

例子：

```
A数列为：3 2 4 5 6 8 1 2 9 7
求区间i到j的最大值（闭区间）RMQ(A, i, j)
```

设：`DP[i,j]`代表从第i个数起，长度为`2^j`个数中的最大值。

如：DP[0，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。同理：

```
DP[0,1] = max(3,2) = 3;
DP[0,2] = max(3,2,4,5) = 5;
DP[0,3] = max(3,2,4,5,6,8,1,2) = 8;
```

二维DP初值：`DP[i, 0] = A[i]`

把`DP[i, j]`计算范围平均分成两段（因为`DP[i, j]`计算范围长度为`2^j`一定是偶数个数字），从 i 到`i + 2^(j-1) - 1`为一段，`i + 2^(j-1)`到`i + 2^j - 1`为一段(长度都为`2^(j-1)`)。用上例说明，当`i=1, j=3`时就是`3,2,4,5 `和 `6,8,1,2`这两段。`DP[i, j]`就是这两段各自最大值中的最大值。

状态转移方程：`DP[i, j] = max(DP[i, j-1], DP[i + 2^(j-1), j-1])`

动态的构建DP这个数组：

```cpp
#include <stdio.h>
#include <math.h>

int** DP;

// 预处理，O(n^2)代价
void RMQ(int* A, int num) {
    for (int i = 0; i < num; ++i) {
        DP[i][0] = A[i];
    }
    for(int j = 1; j <= num; ++j)  {  // 必须从长度开始循环, 因为初始只知道DP[i][0]
        for(int i = 1; i <= num; ++i) {
            if(i + (1 << j) - 1 <= num) {  
                DP[i][j] = max(DP[i][j-1], DP[i + (1 << (j-1))][j-1]);  
            }
        }
    }
} 
int find(int* A, int num, int i, int j) {
    DP = new int*[num];
    for (int i = 0; i < num; ++i) {
        DP[i] = new int*[num];
    }
        
    int k = log(j-i+1) / log(2);
    return max(DP[i , k], DP[j - (1<<k) + 1, k]);
}

```

必须从长度开始循环，计算规律就是先算长度为1的所有最大值，以此为基础算长度为2的最大值。



