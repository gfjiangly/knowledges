给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:

```
输入: [1, 2, 3, 4]

输出: False

解释: 序列中不存在132模式的子序列。
```

示例 2:

```
输入: [3, 1, 4, 2]

输出: True

解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
```

示例 3:

```
输入: [-1, 3, 2, 0]

输出: True

解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
```



## 固定变量法

这个问题由三个变量，暴力解需要三重循环，我们可以考虑固定中间元素，然后从中间元素的左侧找小于中间元素的元素，从右侧找大于中间元素的值。左侧找最小元素，右侧找大于左侧最小的元素，且小于中间元素，示意代码如下：

```cpp
for (int k = 1; k < size-1; ++k) {
    // 左最小值
    int left_min = INT_MIN;
    for (int i = 0; i < k; ++i {
    	// ...
    }

    for (int j = k+1; j <size; j++) {
        if (num[j] > left_min && num[k] > num[j])
            return true;
    }
}
return false;
```

此时时间复杂度为O(n^2)

如果我们从右往左循环，用一个辅助数组记录当前最大元素