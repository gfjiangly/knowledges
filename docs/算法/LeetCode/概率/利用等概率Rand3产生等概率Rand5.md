### 一个结论

设randa为等概率生成[1,2,...,a]的函数，即从1开始到a结束。

一个简单结论：如果A > B，那么randA一定可以实现randB。

```cpp
// 伪码
int randb() {
    int x = ~(1<<31);  // max int
    while (x > b) x = randa();
	return x;
}
```



### 构造A1>B

当A < B时，需要构造一个A1，使得A1>B。

rand3 + rand3 生成的随机数范围是 [2, 6]，不是[1,6]，更不是等概率，因为[1,2,3] + [1,2,3]，其中2和6只出现一次，3=1+2=2+1,4=1+3=2+2=3+1,...

需要将两个rand3偏移开，使得每个结果只出现一次。

`3*rand3 +rand3` 即 [3,6,9]+[1,2,3]  => [4,5,6,7,8,9,10,11,12]每个元素等概率出现。将这些元素偏移到[1,2,3,...,9]，即`rand9=3*(rand3-1)+rand3`，可使用rand9生成rand5。

```cpp
int rand5() {
    int x = ~(1<<31);  // max int
    while (x > 5)
		x = 3 * (rand3()-1) + rand3()  // rand9
    return x;
}
```



### 减少无效状态

如果要求使用rand5实现rand7，则构建`rand25=5*(rand5-1)+rand5`，然后使用rand25来生成rand7，这时会发现无效的状态比有效的状态还多，上面的计算方法效率比比较低了，因为rand9每次生成的数在[7,25]之间就要重新生成，因此要想办法减少无效的数组生成。可放宽条件使`<不超过25的7的最大整数倍数`都可以通过，然后对此结果除以7的余数即可。

```cpp
int rand7() {
    int x = ~(1<<31);  // max int
    while (x > 21)  // 不超过25的7的最大整数倍数 为21. 3*7=21<25, 4*7=28>25
		x = 5 * (rand5()-1) + rand5()  // rand9
    return x%7 + 1;
}
```



### 一般性规律

给定两个生成随机数的函数Randa和Randb，可以通过以下方式轻松构造Randab，生成1到a*b的随机数。

```
Randab = b * (Randa - 1) + Randb
Randab = a * (Randb - 1) + Randa
```

例如，已知`rand3`和`rand5`，生成`rand15 = 3*(rand5-1) + rand3 = 5*(rand3-1) + rand5`