搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

示例1:

```
 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
```


示例2:

```
 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
 输出：-1 （没有找到）
```

提示:

1. arr 长度范围在[1, 1000000]之间

### 二分查找

唯一的难点在于，查找时当前元素值等于左侧邻居元素值等于右侧邻居元素值，此时无法判断当前只位于前半部分还是后半部分，查找退化成顺序查找。

```cpp
int size;
int front = true;
int _search(vector<int>& arr, int i, int j) {
    if (i >= j || i < 0 || j >= size) return -1;  // 未找到
    int m = i + (j - i) / 2;
	if (arr[m] == target) return m;
    else {             
        if (front) {
            if (arr[j] > arr[size-1]) { // j位于前半段
				// 正常二分查找
            } else { // j位于后半段
				// 判断m位于何位置
            }
        } else {
            
        }

    }
}
int search(vector<int>& arr, int target) {
	size = arr.size();
    assert(size > 0);
    if (target < arr[0]) front = false;
    if
}
```

