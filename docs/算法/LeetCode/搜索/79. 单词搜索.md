## 题目描述

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例:

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true.
给定 word = "SEE", 返回 true.
给定 word = "ABCB", 返回 false.
```

## 回溯法

```C++
class Solution {
private:
    int n;
    int m;
    string word;
    bool* flags;
    bool dfs(vector<vector<char>>& board, string curr, int i, int j) {
        if (curr == word) return true;	// 必须先检测此条件
        if (i < 0 || i >= n || j < 0 || j >= m || flags[i*m + j] == 1 || curr.size() > word.size()) return false;

        if (word[curr.size()] != board[i][j]) return false;
        else curr += board[i][j];        
        flags[i*m + j] = true;
        // printf("(%d, %d): %s\n", i, j, curr.c_str());

        int d[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        for (int k = 0; k < 4; ++k) {
            if (dfs(board, curr, i+d[k][0], j+d[k][1])) return true;
        }
        flags[i*m + j] = false;  // 只能清除局部，不能清除所有
        return false;
    }

public:
    bool exist(vector<vector<char>>& board, string word) {
        if (word.size() == 0 || board.size() == 0) return false;
        this->word = word;
        n = board.size();
        m = board[0].size();        
        // printf("board size: (%d, %d)\n", n, m);
        if (word.size() > n*m) return false;  // 容易漏此条件

        flags = new bool[n*m];
        for (int i = 0; i < n*m; ++i) flags[i] = false;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (dfs(board, "", i, j)) return true;
            }
        }
        return false;
    }
};
```

![image-20200109110857435](../../../assets/image-20200109110857435.png)

