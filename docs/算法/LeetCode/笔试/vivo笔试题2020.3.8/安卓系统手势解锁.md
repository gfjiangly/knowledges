## 题目描述

我们都知道安卓有个手势解锁的界面，是一个 3 x 3 的点所绘制出来的网格。

给你两个整数，分别为 m 和 n，其中 1 ≤ m ≤ n ≤ 9，那么请你统计一下有多少种解锁手势，是至少需要经过 m 个点，但是最多经过不超过 n 个点的。

先来了解下什么是一个有效的安卓解锁手势：

1. 每一个解锁手势必须至少经过 m 个点、最多经过 n 个点。
2. 解锁手势里不能设置经过重复的点。
3. 假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对不能跨过任何未被经过的点。
4. 经过点的顺序不同则表示为不同的解锁手势。

![img](assets/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81/v2-6c9c4b681eaeaa7ded4e980126dea8b2_720w.jpg)

```text
解释:

| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

无效手势：4 - 1 - 3 - 6 连接点 1 和点 3 时经过了未被连接过的 2 号点。
无效手势：4 - 1 - 9 - 2 连接点 1 和点 9 时经过了未被连接过的 5 号点。
有效手势：2 - 4 - 1 - 3 - 6 连接点 1 和点 3 是有效的，因为虽然它经过了点 2 ，但是点 2 在该手势中之前已经被连过了。
有效手势：6 - 5 - 4 - 1 - 9 - 2 连接点 1 和点 9 是有效的，因为虽然它经过了按键 5 ，但是点 5 在该手势中之前已经被连过了。
```



## 动态规划

这道题还是蛮难的，当时想用动态规划，但是时间不够思考了(该死的第一题，浪费我大量时间)。

如果只允许划一个点，那么合法的手势是9个。

如果只允许划两个点，考虑不同位置的点有些不同，实际上3x3对称网格，点的相对位置只有3种情况：

1. 中心点。只有1个中心点，每个中心点有8个方向可以划过去，共有8种情况
2. 角点。共有4个角点，每个间点有3个方向划过去，共12种情况。
3. 两个角点中间的点，这里成为间点。共4个间点，每个间点有5个方向划过去，共20种情况。

一共`8+12+20=40`种情况

如果只允许划3个点...

发现好像在前一个基础上讨论要分的情况似乎太多，规划不起来。



## 回溯法

这种类似矩阵路径的问题实际上最适合使用回溯搜索算法。

本题主要起始点不一样，就是一种独立的情况。路径相同，但方向不同的不算重复。但同一条路径中不允许出现重复的点。最外层肯定是一个9个点的循环。我们可以写一个函数判断从一个点到另一个点的合法性，例如：

```cpp
// keypad用于标记一次路径中访问过的点
bool valid(const vector<bool>& keypad, int from, int to) {
    if (from == to) return false;
    int i = min(from, to), j = max(from, to);  // 利用对称性，减少了一半的判断
    // 我们需要关心to这个点有没有被访问过
    if ((i==1 && j==9) || (i==3 && j==7)) return keypad[5] && !keypad[to];
    if ((i==1 || i==4 || i==7) && i+2==j) return keypad[i+1] && !keypad[to];
    if (i<=3 && i+6==j) return keypad[i+3] && !keypad[to];
    return !keypad[to];
}
```

上面合法性判断代码已经是核心代码了，回溯法搜索反而比较简单，只注意搜索下一个路径前要取消标记：

```cpp
int number_of_patterns(int m, int n) {
    vector<bool> keypad(10, false);  // 索引0位置不使用，只使用1-9，便于阅读
    for (int i = 1; i <= 9; ++i) {
        keypad[i] = true;
        find(keypad, i, 1, m, n);
        keypad[i] = false;
    }
    return patterns;
}

void find(vector<bool>& keypad, int from, int step, int m, int n) {        
    if (step == n) {
        ++patterns;           
        return;    
    }
    if (step >= m) ++patterns;  // 只要大于等于m，就是一种合法手势，但此时还需要继续搜索
    for (int i = 1; i <= 9; i++) {         
        if (valid(keypad, from, i)) {
            keypad[i] = true;                
            find(keypad, i, step+1, m, n);
            keypad[i] = false;            
        }
    }
}
```

如果能很轻易写出这些代码，何愁找不到好工作！

