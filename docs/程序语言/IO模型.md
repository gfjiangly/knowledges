### 同步和异步（客户端角度）

同步 就是你知道你什么时候在做什么，做完一件事情再做下一件事情，因此主动权在自己手里。比如通过等待或轮询，你在某个时间点总是知道结果是怎样的（有数据还是没数据等）。
异步 就是你不知道什么时候会发生什么。比如你注册了多个回调函数，你不知道什么时候会被调用以及被调用的是哪一个回调函数。

### 阻塞和非阻塞（服务器角度）

阻塞：一个调用过程必须完成才返回。对于IO操作，如果IO没有准备好，读取或者写入等函数将一直等待。
非阻塞：一个调用过程会立即返回，无论结果怎样。对于IO操作，读取或者写入函数总会立即返回一个状态，要么读取成功，要么读取失败（没有数据或被信号中断等）。
看微博上有人（屈春河的微博）说还有部分阻塞：整个调用过程分为C1，C2，…,Cn步，调用者完成C1,…,Cj步后就返回，而不是等待完成整个调用过程。

### 组合方式

通常有三种组合方式：

- 同步阻塞：所有动作依次顺序执行。单线程可完成。
- 同步非阻塞：调用者一般通过轮询方式检测处理是否完成。单线程可完成。
  对于IO操作来讲，我们熟悉的select/epoll，即IO多路复用，可以认为属于这种工作方式。不过有人说select/epoll是异步阻塞的方式，这是为啥呢？明明select/epoll过程在用户态看来类似于轮询，而读写过程可以非阻塞的。实际上select/epoll过程是阻塞的，但它的好处是可以同时监听多个fd且可以设置超时，并且利用select/epoll的阻塞换取了读写的非阻塞。
- 异步非阻塞：Callback模式，注册回调，等待其他线程利用回调执行后续处理。Linux kernel里面有个aio就是异步非阻塞IO，但好像很多坑。