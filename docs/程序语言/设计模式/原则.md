## 一 单一职责原则

单一职责原则（SRP，Single Responsibility Principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。该原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和Meilir Page-Jones的著作中的内聚性原则发展出的。

### 意图

所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。 总结意图就是解耦。

### 总结

- 不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则；

- 可以降低类的复杂度，一个类只负责一项职责，其逻辑一般比负责多项职责的简单；

- 提高类的可读性，提高系统的可维护性；

- 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，**当修改一个功能时，可以显著降低对其他功能的影响。**

  

## 二 里氏替换原则

最早于1988年由麻省理工学院 Barbara Liskov 女士（里氏）提出。

### 定义

定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。

定义2：所有引用基类的地方必须能透明地使用其子类的对象。

### 问题由来

有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。

### 解决方案

当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。里氏替换原则通俗的来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能，防止通过子类使用父类功能的代码块出现错误**。它包含以下4层含义：
- 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

### 总结

看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？后果就是：你写的代码出问题的几率将会大大增加。



## 三  开放封闭原则

开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。**其他的设计原则，很多时候是为实现这一目标服务的**，例如以Liskov（里式）替换原则实现最佳的、正确的继承层次，就能保证不会违反开放封闭原则。 

<font color=red> 软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 </font>

### 意图

- 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

- 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。

### 总结

- 开放封闭原则，是最为重要的设计原则，但这一原则并没有给出如何实现的具体指导。
- Liskov替换原则和组合模式为开放封闭原则的实现提供保证。
- 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭、对扩展开放的设计思路。
- 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象。
- 拒绝滥用抽象，只将经常变化的部分进行抽象，这种经验可以从设计模式的学习与应用中获得。



## 四 依赖倒置原则

依赖倒置原则（DIP，Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 可以认为是开闭原则的一个体现。

### 意图

面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。

面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。

### 总结

- A. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象
- B. 抽象不应该依赖于具体，具体应该依赖于抽象



## 总结

开闭原则是最重要的，不符合开闭原则的代码，基本上无法复用，软件的价值大大降低！