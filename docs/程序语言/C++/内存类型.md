
一个由C/C++编译的程序占用的内存分为以下几个部分

### 栈区（stack）

程序运行时由系统自动分配，存放函数的参数值，局部变量（自动变量）的值等。其操作方式类似于数据结构中的栈。程序结束后由系统释放

-  由系统自动分配， 速度较快， 程序员无法控制这部分内存分配
-  只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 
- 在Windows下，栈内存是向低地址扩展的，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
- 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量，静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

### 堆区（heap） 

在内存开辟另一块存储区域。一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。由程序员手动释放

-  程序员手动分配，分配速度较慢，且容易产生内存碎片
- 操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
-  对于大多数系统，会在这块内存空间中的首地址处（ 占一个字节 ）记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 
- 堆内存是向高地址扩展的，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

### 全局区（静态区）（static）

编译器编译时即分配内存。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放

### 文字常量区 

常量字符串就是放在这里的。 程序结束后由系统释放

### 程序代码区

存放函数体的二进制代码。 程序结束后由系统释放



注意：这里的内存是软件上人为划分的几个区域。从硬件看，它们所占有的内存结构都是相同的。那么为什么软件上给这些内存取不同名字加以区分呢。原因是内存的使用方式不同（管理方式）。栈内存是先申请的后释放其操作方式类似数据结构中的栈，因此得名栈内存。类似的堆内存，实际上也没有堆内存这种硬件，仅仅是因为这块内存操作方式类似于数据结构中的链表。程序员一般仅需要关注堆内存和栈内存，防止堆内存泄露和栈内存溢出。



### 栈堆内存比较

- 管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

- 空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。

- 能否产生碎片不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。

- 生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

- 分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

- 分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。


  虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。



## 内存类型辨识例子

非常详细



```cpp
// main.cpp

// 全局初始化区char *p1; 全局未初始化区
int a = 0; 
main()
{
    int b;		// 分配在栈内存上
    char s[] = "abc"; 	// 分配在栈内存上
    char *p2; 	// 分配在栈内存上
    char *p3 = "123456"; 	// "123456/0"在常量区，p3在栈内存上
    static int c =0； // 全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);	// 分配的10和20字节的区域在堆内存上
    strcpy(p1, "123456"); 	// 123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}
```



###  new/delete与malloc/free比较 

使用new分配堆空间可以调用类的构造函数，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前会调用析构函数，而free函数则不会。

```C++
// 变量申请
Type* pointer = new Type;
if (points != NULL)
{
    // to do samething
}
// 变量释放
delete pointer;

// 数组申请
Type* pointer = new Type[N];
if (points != NULL)
{
    // to do samething
}
// 数组释放
delete[] pointer;
```

