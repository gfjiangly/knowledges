## CPU 为什么要乱序？

为了效率，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令，隐藏掉一些指令执行的延迟。而且允许排在前面的长费时指令后于排在后面的指令执行完。

CPU乱序优化特点：

- 排在后面的指令可以不等前面的指令执行完毕就开始执行
- 排在前面的指令可能后于排在后面的指令执行完

满足任一条，可认为是乱序执行。

## 乱序执行例子

在 CPU0 上执行下面两句话：

```cpp
a = 1;
b = 2;
```

在以下情况下 b=2 会先于 a=1 执行完：

1. a 没有缓存于 CPU0 的 cache 上
2. b 缓存于 CPU0 的 cache上，且处于 Exclusive 状态。

在一个 CPU 上写入没有缓存的变量流程如下（该图来源于《cache 一致性》）：

![img](assets/CPU%20%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E9%97%AE%E9%A2%98/20160125101859844.png)

CPU0 不能仅仅在它的 cache 里写入 a=1，它还要告诉缓存 a 所在的 其它CPU：你上面的 a 缓存过期(invalidate)了! 等 CPU0 收到响应(Invalidate Ack)后，才能写入。

这一通信过程是需要耗费时间，而且距离收到 ack 的时间是不确定的，这限制于总线的繁忙程度以及 CPU1 是否在执行优先级高的任务等等。所以CPU0 不能干等着，它要向后继续执行指令：b=2，而 b 位于本 cache 上且处于 Exclusive 状态，可以直接修改b的值(b 变为 Modified 状态)。此时b=2已经执行完毕，而 a=1还没有执行完毕！从时序上来讲，这就是乱序执行。

## 乱序执行的分类

### 1 写写乱序

```cpp
a = 1;
b = 2;
```

执行时可能：

```cpp
b = 2;
a = 1;
```

### 2 写读乱序

```cpp
a = 1;
load(b);
```

执行时可能：

```cpp
load(b);
a = 1;
```

### 3 读读乱序

```cpp
load(a);
load(b);
```

执行时可能：

```cpp
load(b);
load(a);
```

### 4 读写乱序

```cpp
load(a);
b = 2;
```

执行时可能：

```cpp
b = 2;
load(a);
```

可见均与内存访问相关，执行顺序与 memory order 在某些场合是一个意思。

## C++ 提供的内存模型约束

可以灵活地根据需要对内存加以约束，达到强度不同的顺序执行效果，如全局的顺序，局部代码的顺序，逻辑相关的顺序等。