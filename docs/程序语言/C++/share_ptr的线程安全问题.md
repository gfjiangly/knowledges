这个问题可分为两个层次考虑，第一个层次是shape_ptr指针本身的线程安全性，第二个层次是share_ptr指向的对象的线程安全性。

ptr是pointer的缩写，share_ptr底层采用引用计数实现，也就是说要讨论share_ptr分别传递到不同线程中，是否会在引用计数上存在竞争问题。share_ptr的引用计数采用了原子操作，因此本身不会有线程安全的问题。

但指向的对象可能存在线程安全问题，智能指针不对指向的对象的线程安全有任何保证。share_ptr内部有两个变量，一个是指向对象的指针ptr，还有一个是引用计数管理对象cnt。在拷贝share_ptr时，首先拷贝智能指针(步骤1)，然后再拷贝指向的对象（步骤2），这两步不是原子操作。

![img](assets/share_ptr%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/20180501163944631)

![img](assets/share_ptr%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/20180501164233241)

所以综合来看，share_ptr是有线程安全性问题的，不同线层读写要加锁。如果share_ptr指向的对象本身具有线程安全性保证，那么不加锁也是可以的。（可以吗？）