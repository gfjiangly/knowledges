## 函数类型限定符

![img](../../assets/1093303-20180919123125957-1702896390.png)

### `__host__`

- `__host__`一般省略。支持C++。
- `__host__`限定的函数内部能调用`__host__`或`__global__`限定的函数

### `__global__`

- `__global__`函数的返回值必须设置为void， 不支持可变参数参数，不能成为类成员函数。注意用`__global__`定义的`kernel`是异步的，这意味着host不会等待kernel执行完就执行下一步。 
- 如果一段代码既需要运行于CPU，也要运行于GPU，我们可以同时使用`__host__`和`__device__`修饰。这样编译器就会帮我们生成两份代码逻辑。 
- `__global__`限定的函数内部只能调用`__device__`限定的函数

### `__device__`

CUDA对`__device__`修饰的函数进行了比较多的优化。比如它会根据它的规则，让某个`__device__`修饰函数成为内联函数（inline）。这些规则是程序员不可控，但是如果我们的确对是否内联有需求，cuda也提供了方式：使用`__noinline__`修饰函数不进行内联优化；使用 `__forceinline__`修饰函数强制进行内联优化，当然这两种修饰符不能同时使用。 

`__device__`限定的函数内部只能调用`__device__`限定的函数

限定的函数仅支持C++的子集C。

## 变量类型限定符

### `__device__`

修饰的变量位于GPU显卡的内存（显存）中，用于全局通信，可称为global memory。

### `__shared__`

修饰的变量位于共享存储区，定义时不能赋值。

该变量具有以下特征：

- 位于线程块的共享存储器空间中
- 与线程块具有相同的生命周期
- 仅可通过块内的所有线程访问

一般用于线程协作

### `__constant__`

修饰的变量在kernal运行过程中不能修改，但可以在__host__中修改。常量内存与全局内存不同，具备缓存。未命中才从常量区访问。

### `__register__`

此类型变量位于SM寄存器内。一般省略不写，但不是所有没修饰的变量都位于寄存器中，也有可能位于local存储区。

GPU的每个SM（流多处理器）有上千个寄存器。CPU与GPU架构的一个主要区别就是CPU与GPU映射寄存器的方式。CPU通过使用寄存器重命名和栈来执行多线程。为了运行一个新任务，CPU需要进行上下文切换，将当前所有寄存器的状态保存到栈上，然后从栈中恢复当前需要执行的新线程上次的执行状态。这些操作需要花费上百个CPU时钟周期。如果在CPU上开启过多的线程，时间将主要花费在上下文的切换上。因此，如果在CPU上开启过多的线程，有效工作的吞吐量将会快速降低。

GPU不使用寄存器重命名机制，而是致力于为每一个线程都分配一个真实的寄存器（毕竟每个SM有上千个）。因此，当需要上下文切换时，所需要的操作就是将指向当前寄存器组的选择器或指针更新，以指向下一个执行的线程束的寄存器组，开销几乎为零。

尽管如此，寄存器数量还是有限的。当寄存器数量不够使用时，编译器将变量置于本地内存(Local Memory)  。Local memory和寄存器都是线程私有的，但local内存是片外内存，其读写的代价和全局变量一样高（为什么不使用更快的内存存放临时变量？），它是由编译器在寄存器全部使用完的时候自动分配的， 可能是大型结构或数组的自动变量，会占用太多的寄存器空间，而编译器确定的数组可能会动态编制索引。在优化程序的时候可以考虑减少block的线程数量以使每个线程有更多的寄存器可使用，这样可减少Local memory的使用，从而加快运行速度。

访问速度顺序为：register > shared > constant > local > device

寄存器和本地内存的关系

- 都可以存放自动变量，在编译阶段确定大小，决定怎么在SM上进行分配的。
- 寄存器和本地内存都是隐式声明。 寄存器和本地内存不像共享内存、设备内存、常量内存和纹理内存显式声明，它们的声明不加任何限定符，就如普通变量一样。如 int a 。
- 寄存器主要承担Scalar variables（标量变量）和编译时已知的静态索引的数组。本地内存主要承担静态的大型数组和结构体。本地内存存储于栈中（stack frame）。 
- 寄存器影响占用率，本地内存影响内存访问速度。 寄存器是SM中稀有资源，它影响线程块在SM上的分配，即影响占用率。本地内存不影响占用率。寄存器片上资源，访问速度极快，本地内存片外资源，访问速度很慢。
  

寄存器和本地内存的矛盾： 
有时，较少的使用寄存器可获得较高的占用率即SM的中线程的利用率较高，对程序性能提升，但局部变量和中间变量的数量是一定，较少的寄存器意味着较多的使用本地内存，本地内存的内存访问延迟很高，对程序性下降。所以，寄存器和本地内存的大小分配是相矛盾的，也就是说，高的占用率不一定有更好的性能。

权衡寄存器和本地内存的使用 ：
由于寄存器和本地内存的在性能上的矛盾，没有确定的普适性的办法，只有根据实际情况具体分析，所遵循的原则是：在占用率不是太低（50%以上），的情况下尽量多使用片上的寄存器资源，但当中间数据比较多时，使用本地内存。 
即： 
当局部变量或中间数据不多时，尽量使用片上的寄存器资源。 
当局部变量或中间数据较多时，仍使用寄存器资源，但要使用一定的策略：可通过减小块的大小的方式来增加每块的寄存器资源，或使用片上的共享内存作为中间数据的临时储存区域，减小寄存器的使用。 
当局部变量或中间数据非常大时，这时需要较多的利用寄存器资源，但迫不得已的使用本地内存。

程序员能控制的是kernel函数内变量的使用，以及线程块的数量和块大小。除此以外，别无他法。

